/* eslint-disable prettier/prettier */
import {
  BadRequestException,
  Injectable,
  NotFoundException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import { Encrypter } from 'src/encryption';
import { Student } from 'src/models';
import { Like, Repository } from 'typeorm';
import {
  AccountDto,
  StudentDto,
  StudentEditDto,
  StudentFilterDto,
} from './dtos';

@Injectable()
export class StudentsService {
  constructor(
    @InjectRepository(Student)
    private readonly studentsRepository: Repository<Student>,
    private readonly jwtService: JwtService,
  ) {}

  /**
   * @primary function
   * @param dto optinal filters for searching
   * @returns array of students
   */
  async searchStudents(dto: StudentFilterDto): Promise<Student[]> {
    const students = await this.decryptStudentsList(
      await this.studentsRepository.find(),
    );
    return dto.email.length > 0
      ? this.getStudentsByEmail(dto.email, students)
      : this.getStudentsByName(dto.name, students);
  }

  /**
   * @primary function
   * @param id student identifier autogenerated
   * @returns complete user
   */
  async getStudent(id: string): Promise<Student> {
    const student = await this.verifyGetStudent(id);
    return await this.decryptStudent(student);
  }

  /**
   * @primary function
   * @param dto student object
   * @returns promise with token
   */
  async addStudent(dto: StudentDto): Promise<any> {
    const studentEncryped = await this.encryptStudent(dto);
    await this.verifyAddStudent(studentEncryped);
    const student = await this.studentsRepository.save(
      this.studentsRepository.create({
        ...studentEncryped,
        status: 'Disponible',
      }),
    );
    return await this.getToken(student);
  }

  /**
   * @primary function
   * @param id student identifier
   * @param dto new student partial data
   * @returns student updated
   */
  async updateStudent(id: string, dto: StudentEditDto): Promise<Student> {
    const studentEncryped = await this.encryptStudentUpdate(dto);
    const student = await this.vetifyUpdateStudent(id, studentEncryped);
    const studentRetrieved = await this.studentsRepository.save(
      Object.assign(student, studentEncryped),
    );
    return await this.decryptStudent(studentRetrieved);
  }

  /**
   * @primary function
   * @param dto account to access
   * @returns access token
   */
  async signInStudent(dto: AccountDto): Promise<any> {
    const student = await this.verifySignInStudent(dto);
    return await this.getToken(student);
  }

  async getToken(student: any): Promise<any> {
    const payload = {
      id: student.id,
      name: student.name,
    };
    return {
      id: student.id,
      name: await Encrypter.desencrypt(student.name),
      access_token: await this.jwtService.signAsync(payload),
    };
  }

  getStudentsByName(name: string, students: Student[]): Student[] {
    const studentsReturn: Student[] = [];
    students.forEach((student) => {
      if (student.name.toLowerCase().indexOf(name.toLowerCase()) >= 0)
        studentsReturn.push(student);
    });
    return studentsReturn;
  }

  getStudentsByEmail(email: string, students: Student[]): Student[] {
    const studentsReturn: Student[] = [];
    students.forEach((student) => {
      if (student.email.toLowerCase().indexOf(email.toLowerCase()) >= 0)
        studentsReturn.push(student);
    });
    return studentsReturn;
  }

  async decryptStudentsList(students: Student[]): Promise<Student[]> {
    const decryptedStudents: Array<Student> = [];
    for (let student of students) {
      decryptedStudents.push(await this.decryptStudent(student));
    }
    return decryptedStudents;
  }

  async decryptStudent(student: Student): Promise<Student> {
    return {
      ...student,
      name: await Encrypter.desencrypt(student.name),
      email: await Encrypter.desencrypt(student.email),
      password: await Encrypter.desencrypt(student.password),
    };
  }

  private async verifySignInStudent(dto: AccountDto): Promise<Student> {
    const student = await this.getStudentByEmail(
      await Encrypter.encrypt(dto.email),
    );
    if (!student)
      throw new NotFoundException([
        'No se contró ningun estudiante con ese email',
      ]);
    if (student.status === 'Bloqueado')
      throw new BadRequestException([
        'Has sido baneado por un administrador del sistema',
      ]);
    if (student.password !== (await Encrypter.encrypt(dto.password)))
      throw new BadRequestException(['La contraseña no coincide con el email']);
    return student;
  }

  async vetifyUpdateStudent(id: string, dto: StudentEditDto): Promise<Student> {
    const student = await this.verifyGetStudent(id);
    if (await this.isEmailDuplicated(student.email, dto.email))
      throw new BadRequestException([
        'El email del estudiante ya ha sido asignado',
      ]);
    return student;
  }

  async verifyGetStudent(id: string): Promise<Student> {
    const student = await this.getStudentById(id);
    if (!student)
      throw new NotFoundException(['El estudiante no fue encontrado']);
    return student;
  }

  async encryptStudent(student: StudentDto): Promise<StudentDto> {
    return {
      email: await Encrypter.encrypt(student.email),
      password: await Encrypter.encrypt(student.password),
      name: await Encrypter.encrypt(student.name),
    };
  }

  async verifyAddStudent(student: StudentDto) {
    if (await this.isEmailDuplicated('', student.email))
      throw new BadRequestException([
        'El email ya fue asignado a otro estudiante',
      ]);
  }

  private async getStudentById(id: string): Promise<Student> {
    return await this.studentsRepository.findOne({ where: { id: id } });
  }

  private async getStudentByEmail(email: string): Promise<Student> {
    return await this.studentsRepository.findOne({
      where: { email: email },
    });
  }

  async encryptStudentUpdate(student: StudentEditDto): Promise<StudentEditDto> {
    return {
      email: await Encrypter.encrypt(student.email),
      password: await Encrypter.encrypt(student.password),
      name: await Encrypter.encrypt(student.name),
      status: student.status,
    };
  }

  private async isEmailDuplicated(
    oldEmail: string,
    newEmail: string,
  ): Promise<boolean> {
    if (!newEmail) return false;
    if (newEmail === oldEmail) return false;
    const student = await this.studentsRepository.findOne({
      where: { email: newEmail },
    });
    return student ? true : false;
  }
}
